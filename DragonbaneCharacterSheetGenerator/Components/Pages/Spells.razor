@page "/spells"
@using System.Text.Json
@using System.Text.Json.Serialization
@using Microsoft.Maui.Storage
@using System.IO
@using System.Text.RegularExpressions
@using System.Linq
@using DragonbaneCharacterSheetGenerator.Shared

@inherits DragonbaneCharacterSheetGenerator.Components.Pages.SpellsBase

<ErrorBoundary Context="err">
    <ChildContent>
        <h1>Spells</h1>

        <p>Browse tricks and spells. Use the filters to narrow by type and school.</p>

        <div class="row mb-3">
            <div class="col-md-3">
                <label class="form-label">Type</label>
                <select class="form-select" @bind="selectedType">
                    <option value="Tricks">Tricks</option>
                    <option value="Spells">Spells</option>
                </select>
            </div>
            <div class="col-md-3">
                <label class="form-label">School</label>
                <select class="form-select" @bind="selectedSchool">
                    <option value="All">All</option>
                    <option value="Animism">Animism</option>
                    <option value="Elementalism">Elementalism</option>
                    <option value="Mentalism">Mentalism</option>
                </select>
            </div>
            <div class="col-md-2">
                <label class="form-label">Max Rank</label>
                <select class="form-select" @bind="selectedMaxRank">
                    <option value="Any">Any</option>
                    @for (int i = 1; i <= 10; i++)
                    {
                        <option value="@i">@i</option>
                    }
                </select>
            </div>
            <div class="col-md-2">
                <label class="form-label">Search</label>
                <input class="form-control" placeholder="Search by name or effect..." @bind="searchTerm" />
            </div>
            <div class="col-md-2 d-flex align-items-end">
                <div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="favOnly" @bind="showFavoritesOnly" />
                        <label class="form-check-label small text-muted" for="favOnly">Favorites only (@(selectedType == "Tricks" ? CountFavoritesForKind("trick") : CountFavoritesForKind("spell")))</label>
                    </div>
                </div>
            </div>
        </div>

        @if (doc == null)
        {
            <p><em>Loading...</em></p>
        }
        else
        {
            @if (selectedType == "Tricks")
            {
                <div class="row mt-3">
                    @foreach (var card in FilteredCards)
                    {
                        var isFav = IsFavoriteItem(card.IsSpell, card.Title);
                        <div class="col-md-6 mb-3">
                            <div class="card h-100 @(isFav ? "border-warning" : "")">
                                <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, false)">
                                    <h5 class="card-title d-flex align-items-center">
                                        <span class="flex-grow-1">@card.Title</span>
                                        <button class="fav-btn @(isFav ? "favorited" : "") ms-2" title="Toggle favorite" @onclick="() => ToggleFavoriteItem(card.IsSpell, card.Title)" @onclick:preventDefault="true" @onclick:stopPropagation="true" aria-label="Toggle favorite">
                                            <i class="@(isFav ? "fa-solid fa-star" : "fa-regular fa-star")" aria-hidden="true"></i>
                                        </button>
                                    </h5>
                                    <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
                                    <p class="card-text">@card.Body</p>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            }
            else
            {
                @* Spells view: if All selected, group by General / Animism / Elementalism / Mentalism *@
                @if (selectedSchool == "All")
                {
                    <h3>General Spells</h3>
                    <div class="row">
                        @foreach (var s in (doc.Spells?.GeneralSpells ?? new List<Spell>()).Where(s => MatchesSearch(s.Name, s.Effect)))
                        {
                            var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank}", Body = s.Effect, IsSpell = true, Spell = s };
                            if (showFavoritesOnly && !IsFavorite("spell", card.Title)) continue;
                            var isFav = IsFavoriteItem(card.IsSpell, card.Title);
                            <div class="col-md-6 mb-3">
                                <div class="card h-100 @(isFav ? "border-warning" : "")">
                                    <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
                                        <h5 class="card-title d-flex align-items-center">
                                            <span class="flex-grow-1">@card.Title</span>
                                            <button class="fav-btn @(isFav ? "favorited" : "") ms-2" title="Toggle favorite" @onclick="() => ToggleFavoriteItem(card.IsSpell, card.Title)" @onclick:preventDefault="true" @onclick:stopPropagation="true" aria-label="Toggle favorite">
                                                <i class="@(isFav ? "fa-solid fa-star" : "fa-regular fa-star")" aria-hidden="true"></i>
                                            </button>
                                        </h5>
                                        <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
                                        <p class="card-text">@card.Body</p>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>

                    <h3 class="mt-4">Animism</h3>
                    <div class="row">
                        @foreach (var s in (doc.Spells?.AnimismSpells ?? new List<Spell>()).Where(s => MatchesSearch(s.Name, s.Effect)))
                        {
                            var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} � Animism", Body = s.Effect, IsSpell = true, Spell = s };
                            if (showFavoritesOnly && !IsFavorite("spell", card.Title)) continue;
                            var isFav = IsFavoriteItem(card.IsSpell, card.Title);
                            <div class="col-md-6 mb-3">
                                <div class="card h-100 @(isFav ? "border-warning" : "")">
                                    <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
                                        <h5 class="card-title d-flex align-items-center">
                                            <span class="flex-grow-1">@card.Title</span>
                                            <button class="fav-btn @(isFav ? "favorited" : "") ms-2" title="Toggle favorite" @onclick="() => ToggleFavoriteItem(card.IsSpell, card.Title)" @onclick:preventDefault="true" @onclick:stopPropagation="true" aria-label="Toggle favorite">
                                                <i class="@(isFav ? "fa-solid fa-star" : "fa-regular fa-star")" aria-hidden="true"></i>
                                            </button>
                                        </h5>
                                        <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
                                        <p class="card-text">@card.Body</p>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>

                    <h3 class="mt-4">Elementalism</h3>
                    <div class="row">
                        @foreach (var s in (doc.Spells?.ElementalismSpells ?? new List<Spell>()).Where(s => MatchesSearch(s.Name, s.Effect)))
                        {
                            var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} � Elementalism", Body = s.Effect, IsSpell = true, Spell = s };
                            if (showFavoritesOnly && !IsFavorite("spell", card.Title)) continue;
                            var isFav = IsFavoriteItem(card.IsSpell, card.Title);
                            <div class="col-md-6 mb-3">
                                <div class="card h-100 @(isFav ? "border-warning" : "")">
                                    <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
                                        <h5 class="card-title d-flex align-items-center">
                                            <span class="flex-grow-1">@card.Title</span>
                                            <button class="fav-btn @(isFav ? "favorited" : "") ms-2" title="Toggle favorite" @onclick="() => ToggleFavoriteItem(card.IsSpell, card.Title)" @onclick:preventDefault="true" @onclick:stopPropagation="true" aria-label="Toggle favorite">
                                                <i class="@(isFav ? "fa-solid fa-star" : "fa-regular fa-star")" aria-hidden="true"></i>
                                            </button>
                                        </h5>
                                        <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
                                        <p class="card-text">@card.Body</p>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>

                    <h3 class="mt-4">Mentalism</h3>
                    <div class="row">
                        @foreach (var s in (doc.Spells?.MentalismSpells ?? new List<Spell>()).Where(s => MatchesSearch(s.Name, s.Effect)))
                        {
                            var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} � Mentalism", Body = s.Effect, IsSpell = true, Spell = s };
                            if (showFavoritesOnly && !IsFavorite("spell", card.Title)) continue;
                            var isFav = IsFavoriteItem(card.IsSpell, card.Title);
                            <div class="col-md-6 mb-3">
                                <div class="card h-100 @(isFav ? "border-warning" : "")">
                                    <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
                                        <h5 class="card-title d-flex align-items-center">
                                            <span class="flex-grow-1">@card.Title</span>
                                            <button class="fav-btn @(isFav ? "favorited" : "") ms-2" title="Toggle favorite" @onclick="() => ToggleFavoriteItem(card.IsSpell, card.Title)" @onclick:preventDefault="true" @onclick:stopPropagation="true" aria-label="Toggle favorite">
                                                <i class="@(isFav ? "fa-solid fa-star" : "fa-regular fa-star")" aria-hidden="true"></i>
                                            </button>
                                        </h5>
                                        <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
                                        <p class="card-text">@card.Body</p>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <div class="row mt-3">
                        @foreach (var card in FilteredCards)
                        {
                            var isFav = IsFavoriteItem(card.IsSpell, card.Title);
                            <div class="col-md-6 mb-3">
                                <div class="card h-100 @(isFav ? "border-warning" : "")">
                                    <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
                                        <h5 class="card-title d-flex align-items-center">
                                            <span class="flex-grow-1">@card.Title</span>
                                            @if (card.IsSpell)
                                            {
                                                <button class="fav-btn @(isFav ? "favorited" : "") ms-2" title="Toggle favorite" @onclick="() => ToggleFavoriteItem(card.IsSpell, card.Title)" @onclick:preventDefault="true" @onclick:stopPropagation="true" aria-label="Toggle favorite">
                                                    <i class="@(isFav ? "fa-solid fa-star" : "fa-regular fa-star")" aria-hidden="true"></i>
                                                </button>
                                            }
                                        </h5>
                                        <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
                                        <p class="card-text">@card.Body</p>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                }
            }

            @* Modal *@
            @if (showModal && modalCard != null)
            {
                <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title d-flex align-items-center">
                                    <span class="flex-grow-1">@modalCard.Title</span>
                                    <button class="fav-btn @(IsFavoriteItem(modalCard.IsSpell, modalCard.Title) ? "favorited" : "") ms-2" title="Toggle favorite" @onclick="() => ToggleFavoriteItem(modalCard.IsSpell, modalCard.Title)" @onclick:preventDefault="true" @onclick:stopPropagation="true" aria-label="Toggle favorite">
                                        <i class="@(IsFavoriteItem(modalCard.IsSpell, modalCard.Title) ? "fa-solid fa-star" : "fa-regular fa-star")" aria-hidden="true"></i>
                                    </button>
                                </h5>
                                <button type="button" class="btn-close" @onclick="CloseModal"></button>
                            </div>
                            <div class="modal-body">
                                <h6 class="text-muted">@modalCard.Subtitle</h6>

                                @if (modalCard.IsSpell && modalCard.Spell != null)
                                {
                                    <div class="mb-2 small text-muted">
                                        <span class="me-3"><strong>Prereq:</strong>
                                            @if (!string.IsNullOrWhiteSpace(modalCard.Spell.Prerequisite))
                                            {
                                                var tokens = SplitPrerequisites(modalCard.Spell.Prerequisite).ToList();
                                                for (int i = 0; i < tokens.Count; i++)
                                                {
                                                    var t = tokens[i];
                                                    var found = FindSpellByName(t);
                                                    if (found != null)
                                                    {
                                                        <a href="#" @onclick="() => OpenPrereqBySpell(found)" @onclick:preventDefault="true" @onclick:stopPropagation="true">@t</a>
                                                    }
                                                    else
                                                    {
                                                        @t
                                                    }
                                                    if (i < tokens.Count - 1)
                                                    {
                                                        <text>, </text>
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                <text>-</text>
                                            }
                                        </span>
                                        <span class="me-3"><strong>Cast:</strong> @(!string.IsNullOrWhiteSpace(modalCard.Spell.CastTime) ? modalCard.Spell.CastTime : "-")</span>
                                        <span class="me-3"><strong>Range:</strong> @(!string.IsNullOrWhiteSpace(modalCard.Spell.Range) ? modalCard.Spell.Range : "-")</span>
                                        <span class="me-3"><strong>Duration:</strong> @(!string.IsNullOrWhiteSpace(modalCard.Spell.Duration) ? modalCard.Spell.Duration : "-")</span>
                                    </div>
                                }

                                <p>@modalCard.Body</p>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" @onclick="CloseModal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            }
        }
    </ChildContent>

    <ErrorContent>
        <div class="alert alert-danger">
            <h4>Unhandled error while rendering Spells</h4>
            <pre>@err.ToString()</pre>
        </div>
    </ErrorContent>
</ErrorBoundary>

@code {
    private SpellsDoc? doc;
    private string selectedType = "Tricks";
    private string selectedSchool = "All";
    private string searchTerm = string.Empty;
    private string selectedMaxRank = "Any";

    private bool showModal;
    private CardView? modalCard;
    private HashSet<string> favorites = new();
    private bool showFavoritesOnly = false;

    private string KeyFor(string kind, string? name) => $"{kind}|{(name ?? string.Empty).Trim()}";
    private bool IsFavorite(string kind, string? name) => favorites.Contains(KeyFor(kind, name));
    private void ToggleFavorite(string kind, string? name)
    {
        if (string.IsNullOrWhiteSpace(name)) return;
        var k = KeyFor(kind, name);
        if (favorites.Contains(k)) favorites.Remove(k); else favorites.Add(k);
        Preferences.Set("favorites", JsonSerializer.Serialize(favorites));
        StateHasChanged();
    }
    private void LoadFavorites()
    {
        try
        {
            var json = Preferences.Get("favorites", "[]");
            favorites = JsonSerializer.Deserialize<HashSet<string>>(json) ?? new HashSet<string>();
        }
        catch { favorites = new HashSet<string>(); }
    }

    private IEnumerable<string> SplitPrerequisites(string? prereq)
    {
        if (string.IsNullOrWhiteSpace(prereq)) return Enumerable.Empty<string>();
        var norm = prereq.Replace(" or ", ",", StringComparison.OrdinalIgnoreCase).Replace(" and ", ",", StringComparison.OrdinalIgnoreCase);
        return norm.Split(',', StringSplitOptions.RemoveEmptyEntries).Select(p => p.Trim());
    }

    private Spell? FindSpellByName(string name)
    {
        if (doc?.Spells == null) return null;
        string n = name.Trim();
        Spell? FindIn(IEnumerable<Spell>? list) => list?.FirstOrDefault(s => string.Equals(s.Name?.Trim(), n, StringComparison.OrdinalIgnoreCase));

        return FindIn(doc.Spells.GeneralSpells) ?? FindIn(doc.Spells.AnimismSpells) ?? FindIn(doc.Spells.ElementalismSpells) ?? FindIn(doc.Spells.MentalismSpells);
    }

    private void OpenPrereqBySpell(Spell s)
    {
        var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank}", Body = s.Effect, IsSpell = true, Spell = s };
        modalCard = card;
        showModal = true;
    }
    private void ToggleFavoriteSpell(string? name) => ToggleFavorite("spell", name);
    private bool IsFavoriteSpell(string? name) => IsFavorite("spell", name);
    private void ToggleFavoriteItem(bool isSpell, string? name) => ToggleFavorite(isSpell ? "spell" : "trick", name);
    private bool IsFavoriteItem(bool isSpell, string? name) => IsFavorite(isSpell ? "spell" : "trick", name);

    private int CountFavoritesForKind(string kind)
    {
        if (favorites == null || favorites.Count == 0) return 0;
        return favorites.Count(f => f != null && f.StartsWith($"{kind}|", StringComparison.OrdinalIgnoreCase));
    }

    private IEnumerable<CardView> FilteredCards
    {
        get
        {
            if (doc == null) return Enumerable.Empty<CardView>();

            var cards = new List<CardView>();

            // parse selected max rank once
            int? maxRank = int.TryParse(selectedMaxRank, out var tmp) ? tmp : (int?)null;

            if (selectedType == "Tricks")
            {
                var all = doc.Tricks?.GeneralTricks ?? new List<Trick>();
                foreach (var t in all)
                {
                    if (!MatchesSearch(t.Name, t.Effect)) continue;
                    var card = new CardView { Title = t.Name, Subtitle = $"WP: {t.WpCost}", Body = t.Effect };
                    if (showFavoritesOnly && !IsFavorite("trick", card.Title)) continue;
                    cards.Add(card);
                }

                if (selectedSchool == "All")
                {
                    // include each school list if present
                    var tricksBySchool = new Dictionary<string, List<Trick>?> {
                        { "Animism", doc.Tricks?.Animism },
                        { "Elementalism", doc.Tricks?.Elementalism },
                        { "Mentalism", doc.Tricks?.Mentalism }
                    };

                    foreach (var kv in tricksBySchool)
                    {
                        if (kv.Value == null) continue;
                        foreach (var t in kv.Value)
                        {
                            if (!MatchesSearch(t.Name, t.Effect)) continue;
                            var card = new CardView { Title = t.Name, Subtitle = $"WP: {t.WpCost} â€” {kv.Key}", Body = t.Effect };
                            if (showFavoritesOnly && !IsFavorite("trick", card.Title)) continue;
                            cards.Add(card);
                        }
                    }
                }
                else
                {
                    List<Trick>? list = selectedSchool switch
                    {
                        "Animism" => doc.Tricks?.Animism,
                        "Elementalism" => doc.Tricks?.Elementalism,
                        "Mentalism" => doc.Tricks?.Mentalism,
                        _ => null
                    };
                    if (list != null)
                    {
                        foreach (var t in list)
                        {
                            if (!MatchesSearch(t.Name, t.Effect)) continue;
                            var card = new CardView { Title = t.Name, Subtitle = $"WP: {t.WpCost} â€” {selectedSchool}", Body = t.Effect };
                            if (showFavoritesOnly && !IsFavorite("trick", card.Title)) continue;
                            cards.Add(card);
                        }
                    }
                }
            }
            else // Spells
            {
                // include general_spells always
                foreach (var s in doc.Spells?.GeneralSpells ?? new List<Spell>())
                {
                    if (!MatchesSearch(s.Name, s.Effect)) continue;

                    // apply max rank filter: if user specified a maxRank and the spell's rank is numeric and higher, skip
                    if (maxRank.HasValue && int.TryParse(s.Rank?.Trim(), out var rVal) && rVal > maxRank.Value) continue;

                    var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} â€” {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
                    if (!showFavoritesOnly || IsFavorite("spell", card.Title)) cards.Add(card);
                }

                if (selectedSchool == "All")
                {
                    foreach (var s in doc.Spells?.AnimismSpells ?? new List<Spell>())
                    {
                        if (!MatchesSearch(s.Name, s.Effect)) continue;
                        if (maxRank.HasValue && int.TryParse(s.Rank?.Trim(), out var rVal) && rVal > maxRank.Value) continue;
                        var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} â€” Animism â€” {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
                        if (!showFavoritesOnly || IsFavorite("spell", card.Title)) cards.Add(card);
                    }
                    foreach (var s in doc.Spells?.ElementalismSpells ?? new List<Spell>())
                    {
                        if (!MatchesSearch(s.Name, s.Effect)) continue;
                        if (maxRank.HasValue && int.TryParse(s.Rank?.Trim(), out var rVal) && rVal > maxRank.Value) continue;
                        var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} â€” Elementalism â€” {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
                        if (!showFavoritesOnly || IsFavorite("spell", card.Title)) cards.Add(card);
                    }
                    foreach (var s in doc.Spells?.MentalismSpells ?? new List<Spell>())
                    {
                        if (!MatchesSearch(s.Name, s.Effect)) continue;
                        if (maxRank.HasValue && int.TryParse(s.Rank?.Trim(), out var rVal) && rVal > maxRank.Value) continue;
                        var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} â€” Mentalism â€” {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
                        if (!showFavoritesOnly || IsFavorite("spell", card.Title)) cards.Add(card);
                    }
                }
                else if (selectedSchool == "Animism")
                {
                    foreach (var s in doc.Spells?.AnimismSpells ?? new List<Spell>())
                    {
                        if (!MatchesSearch(s.Name, s.Effect)) continue;
                        if (maxRank.HasValue && int.TryParse(s.Rank?.Trim(), out var rVal) && rVal > maxRank.Value) continue;
                        var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} â€” Animism â€” {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
                        if (!showFavoritesOnly || IsFavorite("spell", card.Title)) cards.Add(card);
                    }
                }
                else if (selectedSchool == "Elementalism")
                {
                    foreach (var s in doc.Spells?.ElementalismSpells ?? new List<Spell>())
                    {
                        if (!MatchesSearch(s.Name, s.Effect)) continue;
                        if (maxRank.HasValue && int.TryParse(s.Rank?.Trim(), out var rVal) && rVal > maxRank.Value) continue;
                        var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} â€” Elementalism â€” {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
                        if (!showFavoritesOnly || IsFavorite("spell", card.Title)) cards.Add(card);
                    }
                }
                else if (selectedSchool == "Mentalism")
                {
                    foreach (var s in doc.Spells?.MentalismSpells ?? new List<Spell>())
                    {
                        if (!MatchesSearch(s.Name, s.Effect)) continue;
                        if (maxRank.HasValue && int.TryParse(s.Rank?.Trim(), out var rVal) && rVal > maxRank.Value) continue;
                        var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} â€” Mentalism â€” {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
                        if (!showFavoritesOnly || IsFavorite("spell", card.Title)) cards.Add(card);
                    }
                }
            }

            // apply search filter already done per-item
            return cards;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await using var stream = await FileSystem.OpenAppPackageFileAsync("wwwroot/doc/spells.json");
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            doc = await JsonSerializer.DeserializeAsync<SpellsDoc>(stream, options);
        }
        catch (Exception ex)
        {
            doc = new SpellsDoc();
            // add an error card
            doc.Spells = new SpellsSection { GeneralSpells = new List<Spell> { new Spell { Name = "Error loading spells", Rank = "-", Requirements = "-", Range = "-", Duration = "-", Effect = ex.Message } } };
        }

        LoadFavorites();
    }

    private bool MatchesSearch(string? name, string? body)
    {
        if (string.IsNullOrWhiteSpace(searchTerm)) return true;
        return (name ?? string.Empty).Contains(searchTerm, StringComparison.OrdinalIgnoreCase) || (body ?? string.Empty).Contains(searchTerm, StringComparison.OrdinalIgnoreCase);
    }

    private void OpenModal(CardView card, bool isSpell)
    {
        modalCard = card;
        showModal = true;
        modalCard.IsSpell = isSpell;
    }

    private void CloseModal()
    {
        showModal = false;
        modalCard = null;
    }

    private string GetScaledEffect(CardView card, int powerLevel = 1)
    {
        // Simple heuristic scaling: if the effect text mentions "increases the number of dice" or "Each additional power level",
        // try to find the first dice expression like2D6 and add (powerLevel-1) dice when appropriate.
        var text = card.Body ?? string.Empty;
        try
        {
            if (powerLevel <= 1) return text;

            var lower = text.ToLowerInvariant();
            var increasesNumberOfDice = lower.Contains("increases the number of dice") || lower.Contains("number of dice rolled") || lower.Contains("each additional power level increases the number of dice") || lower.Contains("each power level beyond the first increases the number of dice");
            var increasesDamageByDie = Regex.Match(lower, "increases the damage by d(\\d+)");

            // match first NdM pattern
            var m = Regex.Match(text, "(\\d+)D(\\d+)", RegexOptions.IgnoreCase);
            if (m.Success)
            {
                int baseCount = int.Parse(m.Groups[1].Value);
                int dieSize = int.Parse(m.Groups[2].Value);

                if (increasesNumberOfDice)
                {
                    int newCount = baseCount + (powerLevel - 1);
                    return Regex.Replace(text, "(\\d+)D(\\d+)", $"{newCount}D{dieSize}");
                }

                if (increasesDamageByDie.Success)
                {
                    int incDie = int.Parse(increasesDamageByDie.Groups[1].Value);
                    // return a combined damage description: base + (powerLevel-1) * incDie
                    return text + $"\n\nScaled damage: {baseCount}D{dieSize} + {powerLevel - 1}D{incDie} (for power level {powerLevel})";
                }
            }

            // fallback: if mentions "increases the damage by dX", show that
            if (increasesDamageByDie.Success)
            {
                int incDie = int.Parse(increasesDamageByDie.Groups[1].Value);
                return text + $"\n\nScaled increase: +{powerLevel - 1}D{incDie} (for power level {powerLevel})";
            }

            // default: just show the effect and selected power level
            return text;
        }
        catch
        {
            return text;
        }
    }

    private static string ExpandRequirements(string? req)
    {
        if (string.IsNullOrWhiteSpace(req)) return string.Empty;
        // map abbreviations from spells.json notes (line ~598): W = word (spoken), G = gesture, I = ingredient, F = focus (holy symbol)
        var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "W", "Word (spoken)" },
            { "G", "Gesture" },
            { "I", "Ingredient" },
            { "F", "Focus (holy symbol)" }
        };

        var parts = req.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        var expanded = new List<string>();
        foreach (var p in parts)
        {
            if (map.TryGetValue(p, out var val)) expanded.Add(val);
            else expanded.Add(p);
        }

        return string.Join(", ", expanded);
    }

    private class CardView
    {
        public string? Title { get; set; }
        public string? Subtitle { get; set; }
        public string? Body { get; set; }
        public bool IsSpell { get; set; }
        public Spell? Spell { get; set; }
    }

    private class SpellsDoc
    {
        [JsonPropertyName("tricks")]
        public TricksSection? Tricks { get; set; }

        [JsonPropertyName("spells")]
        public SpellsSection? Spells { get; set; }

        [JsonPropertyName("notes")]
        public string? Notes { get; set; }

        [JsonPropertyName("version")]
        public string? Version { get; set; }
    }

    private class TricksSection
    {
        [JsonPropertyName("general_tricks")]
        public List<Trick>? GeneralTricks { get; set; }

        [JsonPropertyName("Animism")]
        public List<Trick>? Animism { get; set; }

        [JsonPropertyName("Elementalism")]
        public List<Trick>? Elementalism { get; set; }

        [JsonPropertyName("Mentalism")]
        public List<Trick>? Mentalism { get; set; }
    }

    private class SpellsSection
    {
        [JsonPropertyName("general_spells")]
        public List<Spell>? GeneralSpells { get; set; }

        [JsonPropertyName("animism_spells")]
        public List<Spell>? AnimismSpells { get; set; }

        [JsonPropertyName("elementalism_spells")]
        public List<Spell>? ElementalismSpells { get; set; }

        [JsonPropertyName("mentalism_spells")]
        public List<Spell>? MentalismSpells { get; set; }
    }

    private class Trick
    {
        [JsonPropertyName("name")]
        public string? Name { get; set; }
        [JsonPropertyName("wp_cost")]
        public int? WpCost { get; set; }
        [JsonPropertyName("effect")]
        public string? Effect { get; set; }
    }

    private class Spell
    {
        [JsonPropertyName("name")]
        public string? Name { get; set; }
        [JsonPropertyName("rank")]
        public string? Rank { get; set; }
        [JsonPropertyName("requirements")]
        public string? Requirements { get; set; }
        [JsonPropertyName("cast_time")]
        public string? CastTime { get; set; }
        [JsonPropertyName("range")]
        public string? Range { get; set; }
        [JsonPropertyName("duration")]
        public string? Duration { get; set; }
        [JsonPropertyName("effect")]
        public string? Effect { get; set; }
        [JsonPropertyName("prerequisite")]
        public string? Prerequisite { get; set; }
    }
}
