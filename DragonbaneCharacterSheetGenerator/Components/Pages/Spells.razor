@page "/spells"
@using System.Text.Json
@using System.Text.Json.Serialization
@using Microsoft.Maui.Storage
@using System.Text.RegularExpressions
@using System.Linq

<ErrorBoundary Context="err">
 <ChildContent>
 <h1>Spells</h1>

 <p>Browse tricks and spells. Use the filters to narrow by type and school.</p>

 <div class="row mb-3">
 <div class="col-md-4">
 <label class="form-label">Type</label>
 <select class="form-select" @bind="selectedType">
 <option value="Tricks">Tricks</option>
 <option value="Spells">Spells</option>
 </select>
 </div>
 <div class="col-md-4">
 <label class="form-label">School</label>
 <select class="form-select" @bind="selectedSchool">
 <option value="All">All</option>
 <option value="Animism">Animism</option>
 <option value="Elementalism">Elementalism</option>
 <option value="Mentalism">Mentalism</option>
 </select>
 </div>
 <div class="col-md-4">
 <label class="form-label">Search</label>
 <input class="form-control" placeholder="Search by name or effect..." @bind="searchTerm" />
 </div>
 </div>

 @if (doc == null)
 {
 <p><em>Loading...</em></p>
 }
 else
 {
 @if (selectedType == "Tricks")
 {
 <div class="row mt-3">
 @foreach (var card in FilteredCards)
 {
 <div class="col-md-6 mb-3">
 <div class="card h-100">
 <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, false)">
 <h5 class="card-title">@card.Title</h5>
 <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
 <p class="card-text">@card.Body</p>
 </div>
 </div>
 </div>
 }
 </div>
 }
 else
 {
 @* Spells view: if All selected, group by General / Animism / Elementalism / Mentalism *@
 @if (selectedSchool == "All")
 {
 <h3>General Spells</h3>
 <div class="row">
 @foreach (var s in (doc.Spells?.GeneralSpells ?? Enumerable.Empty<Spell>()).Where(s => MatchesSearch(s.Name, s.Effect)))
 {
 var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
 <div class="col-md-6 mb-3">
 <div class="card h-100">
 <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
 <h5 class="card-title">@card.Title</h5>
 <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
 <p class="card-text">@card.Body</p>
 </div>
 </div>
 </div>
 }
 </div>

 <h3 class="mt-4">Animism</h3>
 <div class="row">
 @foreach (var s in (doc.Spells?.AnimismSpells ?? Enumerable.Empty<Spell>()).Where(s => MatchesSearch(s.Name, s.Effect)))
 {
 var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Animism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
 <div class="col-md-6 mb-3">
 <div class="card h-100">
 <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
 <h5 class="card-title">@card.Title</h5>
 <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
 <p class="card-text">@card.Body</p>
 </div>
 </div>
 </div>
 }
 </div>

 <h3 class="mt-4">Elementalism</h3>
 <div class="row">
 @foreach (var s in (doc.Spells?.ElementalismSpells ?? Enumerable.Empty<Spell>()).Where(s => MatchesSearch(s.Name, s.Effect)))
 {
 var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Elementalism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
 <div class="col-md-6 mb-3">
 <div class="card h-100">
 <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
 <h5 class="card-title">@card.Title</h5>
 <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
 <p class="card-text">@card.Body</p>
 </div>
 </div>
 </div>
 }
 </div>

 <h3 class="mt-4">Mentalism</h3>
 <div class="row">
 @foreach (var s in (doc.Spells?.MentalismSpells ?? Enumerable.Empty<Spell>()).Where(s => MatchesSearch(s.Name, s.Effect)))
 {
 var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Mentalism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
 <div class="col-md-6 mb-3">
 <div class="card h-100">
 <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
 <h5 class="card-title">@card.Title</h5>
 <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
 <p class="card-text">@card.Body</p>
 </div>
 </div>
 </div>
 }
 </div>
 }
 else
 {
 <div class="row mt-3">
 @foreach (var card in FilteredCards)
 {
 <div class="col-md-6 mb-3">
 <div class="card h-100">
 <div class="card-body" style="cursor:pointer;" @onclick="() => OpenModal(card, true)">
 <h5 class="card-title">@card.Title</h5>
 <h6 class="card-subtitle mb-2 text-muted">@card.Subtitle</h6>
 <p class="card-text">@card.Body</p>
 </div>
 </div>
 </div>
 }
 </div>
 }
 }
 }

 @* Modal *@
 @if (showModal && modalCard != null)
 {
 <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
 <div class="modal-dialog modal-lg">
 <div class="modal-content">
 <div class="modal-header">
 <h5 class="modal-title">@modalCard.Title</h5>
 <button type="button" class="btn-close" @onclick="CloseModal"></button>
 </div>
 <div class="modal-body">
 <h6 class="text-muted">@modalCard.Subtitle</h6>

 @if (modalCard.IsSpell && modalCard.Spell != null)
 {
 <div class="mb-2 small text-muted">
 <span class="me-3"><strong>Prereq:</strong>
 @if (!string.IsNullOrWhiteSpace(modalCard.Spell.Prerequisite))
 {
 var tokens = SplitPrerequisites(modalCard.Spell.Prerequisite).ToList();
 for (int i = 0; i < tokens.Count; i++)
 {
 var t = tokens[i];
 var found = FindSpellByName(t);
 if (found != null)
 {
 <a href="#" @onclick="() => OpenPrereqBySpell(found)" @onclick:preventDefault="true">@t</a>
 }
 else
 {
 @t
 }
 if (i < tokens.Count - 1)
 {
 <text>, </text>
 }
 }
 }
 else
 {
 <text>-</text>
 }
 </span>
 <span class="me-3"><strong>Cast:</strong> @(!string.IsNullOrWhiteSpace(modalCard.Spell.CastTime) ? modalCard.Spell.CastTime : "-")</span>
 <span class="me-3"><strong>Range:</strong> @(!string.IsNullOrWhiteSpace(modalCard.Spell.Range) ? modalCard.Spell.Range : "-")</span>
 <span class="me-3"><strong>Duration:</strong> @(!string.IsNullOrWhiteSpace(modalCard.Spell.Duration) ? modalCard.Spell.Duration : "-")</span>
 </div>
 }

 <p>@modalCard.Body</p>
 </div>
 <div class="modal-footer">
 <button class="btn btn-secondary" @onclick="CloseModal">Close</button>
 </div>
 </div>
 </div>
 </div>
 }
 </ChildContent>

 <ErrorContent>
 <div class="alert alert-danger">
 <h4>Unhandled error while rendering Spells</h4>
 <pre>@err.ToString()</pre>
 </div>
 </ErrorContent>
</ErrorBoundary>

@code {
 private SpellsDoc? doc;
 private string selectedType = "Tricks";
 private string selectedSchool = "All";
 private string searchTerm = string.Empty;

 private bool showModal;
 private CardView? modalCard;

    private IEnumerable<string> SplitPrerequisites(string? prereq)
    {
        if (string.IsNullOrWhiteSpace(prereq)) return Enumerable.Empty<string>();
        var norm = prereq.Replace(" or ", ",", StringComparison.OrdinalIgnoreCase).Replace(" and ", ",", StringComparison.OrdinalIgnoreCase);
        return norm.Split(',', StringSplitOptions.RemoveEmptyEntries).Select(p => p.Trim());
    }

    private Spell? FindSpellByName(string name)
    {
        if (doc?.Spells == null) return null;
        string n = name.Trim();
        Spell? FindIn(IEnumerable<Spell>? list) => list?.FirstOrDefault(s => string.Equals(s.Name?.Trim(), n, StringComparison.OrdinalIgnoreCase));

        return FindIn(doc.Spells.GeneralSpells) ?? FindIn(doc.Spells.AnimismSpells) ?? FindIn(doc.Spells.ElementalismSpells) ?? FindIn(doc.Spells.MentalismSpells);
    }

    private void OpenPrereqBySpell(Spell s)
    {
        var card = new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s };
        modalCard = card;
        showModal = true;
    }

 private IEnumerable<CardView> FilteredCards
 {
 get
 {
 if (doc == null) return Enumerable.Empty<CardView>();

 var cards = new List<CardView>();

 if (selectedType == "Tricks")
 {
 var all = doc.Tricks?.GeneralTricks ?? new List<Trick>();
 foreach (var t in all)
 {
 if (!MatchesSearch(t.Name, t.Effect)) continue;
 cards.Add(new CardView { Title = t.Name, Subtitle = $"WP: {t.WpCost}", Body = t.Effect });
 }

 if (selectedSchool == "All")
 {
 // include each school list if present
 var tricksBySchool = new Dictionary<string, List<Trick>?> {
 { "Animism", doc.Tricks?.Animism },
 { "Elementalism", doc.Tricks?.Elementalism },
 { "Mentalism", doc.Tricks?.Mentalism }
 };

 foreach (var kv in tricksBySchool)
 {
 if (kv.Value == null) continue;
 foreach (var t in kv.Value)
 {
 if (!MatchesSearch(t.Name, t.Effect)) continue;
 cards.Add(new CardView { Title = t.Name, Subtitle = $"WP: {t.WpCost} — {kv.Key}", Body = t.Effect });
 }
 }
 }
 else
 {
 List<Trick>? list = selectedSchool switch
 {
 "Animism" => doc.Tricks?.Animism,
 "Elementalism" => doc.Tricks?.Elementalism,
 "Mentalism" => doc.Tricks?.Mentalism,
 _ => null
 };
 if (list != null)
 {
 foreach (var t in list)
 {
 if (!MatchesSearch(t.Name, t.Effect)) continue;
 cards.Add(new CardView { Title = t.Name, Subtitle = $"WP: {t.WpCost} — {selectedSchool}", Body = t.Effect });
 }
 }
 }
 }
 else // Spells
 {
 // include general_spells always
 foreach (var s in doc.Spells?.GeneralSpells ?? new List<Spell>())
 {
 if (!MatchesSearch(s.Name, s.Effect)) continue;
 cards.Add(new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s });
 }

 if (selectedSchool == "All")
 {
 foreach (var s in doc.Spells?.AnimismSpells ?? new List<Spell>())
 {
 if (!MatchesSearch(s.Name, s.Effect)) continue;
 cards.Add(new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Animism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s });
 }
 foreach (var s in doc.Spells?.ElementalismSpells ?? new List<Spell>())
 {
 if (!MatchesSearch(s.Name, s.Effect)) continue;
 cards.Add(new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Elementalism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s });
 }
 foreach (var s in doc.Spells?.MentalismSpells ?? new List<Spell>())
 {
 if (!MatchesSearch(s.Name, s.Effect)) continue;
 cards.Add(new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Mentalism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s });
 }
 }
 else if (selectedSchool == "Animism")
 {
 foreach (var s in doc.Spells?.AnimismSpells ?? new List<Spell>())
 {
 if (!MatchesSearch(s.Name, s.Effect)) continue;
 cards.Add(new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Animism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s });
 }
 }
 else if (selectedSchool == "Elementalism")
 {
 foreach (var s in doc.Spells?.ElementalismSpells ?? new List<Spell>()
 )
 {
 if (!MatchesSearch(s.Name, s.Effect)) continue;
 cards.Add(new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Elementalism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s });
 }
 }
 else if (selectedSchool == "Mentalism")
 {
 foreach (var s in doc.Spells?.MentalismSpells ?? new List<Spell>())
 {
 if (!MatchesSearch(s.Name, s.Effect)) continue;
 cards.Add(new CardView { Title = s.Name, Subtitle = $"Rank: {s.Rank} — Mentalism — {ExpandRequirements(s.Requirements)}", Body = s.Effect, IsSpell = true, Spell = s });
 }
 }
 }

 // apply search filter already done per-item
 return cards;
 }
 }

 protected override async Task OnInitializedAsync()
 {
 try
 {
 await using var stream = await FileSystem.OpenAppPackageFileAsync("wwwroot/doc/spells.json");
 var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
 doc = await JsonSerializer.DeserializeAsync<SpellsDoc>(stream, options);
 }
 catch (Exception ex)
 {
 doc = new SpellsDoc();
 // add an error card
 doc.Spells = new SpellsSection { GeneralSpells = new List<Spell> { new Spell { Name = "Error loading spells", Rank = "-", Requirements = "-", Range = "-", Duration = "-", Effect = ex.Message } } };
 }
 }

 private bool MatchesSearch(string? name, string? body)
 {
 if (string.IsNullOrWhiteSpace(searchTerm)) return true;
 return (name ?? string.Empty).Contains(searchTerm, StringComparison.OrdinalIgnoreCase) || (body ?? string.Empty).Contains(searchTerm, StringComparison.OrdinalIgnoreCase);
 }

 private void OpenModal(CardView card, bool isSpell)
 {
 modalCard = card;
 showModal = true;
 modalCard.IsSpell = isSpell;
 }

 private void CloseModal()
 {
 showModal = false;
 modalCard = null;
 }

 private string GetScaledEffect(CardView card, int powerLevel = 1)
 {
 // Simple heuristic scaling: if the effect text mentions "increases the number of dice" or "Each additional power level",
 // try to find the first dice expression like2D6 and add (powerLevel-1) dice when appropriate.
 var text = card.Body ?? string.Empty;
 try
 {
 if (powerLevel <=1) return text;

 var lower = text.ToLowerInvariant();
 var increasesNumberOfDice = lower.Contains("increases the number of dice") || lower.Contains("number of dice rolled") || lower.Contains("each additional power level increases the number of dice") || lower.Contains("each power level beyond the first increases the number of dice");
 var increasesDamageByDie = Regex.Match(lower, "increases the damage by d(\\d+)");

 // match first NdM pattern
 var m = Regex.Match(text, "(\\d+)D(\\d+)", RegexOptions.IgnoreCase);
 if (m.Success)
 {
 int baseCount = int.Parse(m.Groups[1].Value);
 int dieSize = int.Parse(m.Groups[2].Value);

 if (increasesNumberOfDice)
 {
 int newCount = baseCount + (powerLevel -1);
 return Regex.Replace(text, "(\\d+)D(\\d+)", $"{newCount}D{dieSize}");
 }

 if (increasesDamageByDie.Success)
 {
 int incDie = int.Parse(increasesDamageByDie.Groups[1].Value);
 // return a combined damage description: base + (powerLevel-1) * incDie
 return text + $"\n\nScaled damage: {baseCount}D{dieSize} + {powerLevel -1}D{incDie} (for power level {powerLevel})";
 }
 }

 // fallback: if mentions "increases the damage by dX", show that
 if (increasesDamageByDie.Success)
 {
 int incDie = int.Parse(increasesDamageByDie.Groups[1].Value);
 return text + $"\n\nScaled increase: +{powerLevel -1}D{incDie} (for power level {powerLevel})";
 }

 // default: just show the effect and selected power level
 return text;
 }
 catch
 {
 return text;
 }
 }

 private static string ExpandRequirements(string? req)
 {
 if (string.IsNullOrWhiteSpace(req)) return string.Empty;
 // map abbreviations from spells.json notes (line ~598): W = word (spoken), G = gesture, I = ingredient, F = focus (holy symbol)
 var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
 {
 { "W", "Word (spoken)" },
 { "G", "Gesture" },
 { "I", "Ingredient" },
 { "F", "Focus (holy symbol)" }
 };

 var parts = req.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
 var expanded = new List<string>();
 foreach (var p in parts)
 {
 if (map.TryGetValue(p, out var val)) expanded.Add(val);
 else expanded.Add(p);
 }

 return string.Join(", ", expanded);
 }

 private class CardView
 {
 public string? Title { get; set; }
 public string? Subtitle { get; set; }
 public string? Body { get; set; }
 public bool IsSpell { get; set; }
 public Spell? Spell { get; set; }
 }

 private class SpellsDoc
 {
 [JsonPropertyName("tricks")]
 public TricksSection? Tricks { get; set; }

 [JsonPropertyName("spells")]
 public SpellsSection? Spells { get; set; }

 [JsonPropertyName("notes")]
 public string? Notes { get; set; }

 [JsonPropertyName("version")]
 public string? Version { get; set; }
 }

 private class TricksSection
 {
 [JsonPropertyName("general_tricks")]
 public List<Trick>? GeneralTricks { get; set; }

 [JsonPropertyName("Animism")]
 public List<Trick>? Animism { get; set; }

 [JsonPropertyName("Elementalism")]
 public List<Trick>? Elementalism { get; set; }

 [JsonPropertyName("Mentalism")]
 public List<Trick>? Mentalism { get; set; }
 }

 private class SpellsSection
 {
 [JsonPropertyName("general_spells")]
 public List<Spell>? GeneralSpells { get; set; }

 [JsonPropertyName("animism_spells")]
 public List<Spell>? AnimismSpells { get; set; }

 [JsonPropertyName("elementalism_spells")]
 public List<Spell>? ElementalismSpells { get; set; }

 [JsonPropertyName("mentalism_spells")]
 public List<Spell>? MentalismSpells { get; set; }
 }

 private class Trick
 {
 [JsonPropertyName("name")]
 public string? Name { get; set; }
 [JsonPropertyName("wp_cost")]
 public int? WpCost { get; set; }
 [JsonPropertyName("effect")]
 public string? Effect { get; set; }
 }

 private class Spell
 {
 [JsonPropertyName("name")]
 public string? Name { get; set; }
 [JsonPropertyName("rank")]
 public string? Rank { get; set; }
 [JsonPropertyName("requirements")]
 public string? Requirements { get; set; }
 [JsonPropertyName("cast_time")]
 public string? CastTime { get; set; }
 [JsonPropertyName("range")]
 public string? Range { get; set; }
 [JsonPropertyName("duration")]
 public string? Duration { get; set; }
 [JsonPropertyName("effect")]
 public string? Effect { get; set; }
 [JsonPropertyName("prerequisite")]
 public string? Prerequisite { get; set; }
 }
}
